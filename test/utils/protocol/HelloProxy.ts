// **********************************************************************
// Parsed By TarsParser(1.1.0), Generated By tars2node(20190529)
// TarsParser Maintained By <TARS> and tars2node Maintained By <superzheng>
// Generated from "Hello.tars" by Client Mode
// **********************************************************************

/* tslint:disable */
/* eslint-disable */

/// <reference types="node" />
import assert = require("assert");
import * as TarsStream from "@tars/stream";
import * as TarsRpc from "@tars/rpc";

const _hasOwnProperty = Object.prototype.hasOwnProperty;
function _castFunctionInfo<Ret, Arg>(data: SharedFunctionInfo<Ret, Arg>) { return data; }
function _makeError(data: TarsRpc.RpcResponse, message: string, type?: number): TarsRpc.RpcError {
    var error: any = new Error(message || "");
    error.request = data.request;
    error.response = {
        costtime: data.request.costtime
    };
    if (type === TarsRpc.error.CLIENT.DECODE_ERROR) {
        error.name = "DECODE_ERROR";
        error.response.error = {
            code: type,
            message: message
        };
    } else {
        error.name = "RPC_ERROR";
        error.response.error = data.error;
    }
    return error;
}

export interface SharedFunctionInfo<Ret = any, Arg = any> extends TarsRpc.SharedFunctionInfo {
    tarsEncoder (...args: any[]): TarsStream.BinBuffer,
    tarsDecoder (data: TarsRpc.RpcResponse): TarsRpc.ProxyResponse<Ret, Arg>,
    tupEncoder (...args: any[]): TarsStream.UniAttribute,
    tupDecoder (data: TarsRpc.RpcResponse): TarsRpc.ProxyResponse<Ret, Arg>,
    errorResponser (data: TarsRpc.RpcResponse): never
}

export namespace Hello {
    export class TestReq {
        sName: string = "";
        iAge: number = 0;

        protected _proto_struct_name_ = "";
        protected _classname = "Hello.TestReq";
        protected static _classname = "Hello.TestReq";
        protected static _write(os: TarsStream.TarsOutputStream, tag: number, val: any) { os.writeStruct(tag, val); }
        protected static _read(is: TarsStream.TarsInputStream, tag: number, def?: any) { return is.readStruct(tag, true, def); }
        protected static _readFrom(is: TarsStream.TarsInputStream) {
            const tmp = new TestReq;
            tmp.sName = is.readString(0, false, "");
            tmp.iAge = is.readInt32(1, false, 0);
            return tmp;
        }

        protected _writeTo(os: TarsStream.TarsOutputStream) {
            os.writeString(0, this.sName);
            os.writeInt32(1, this.iAge);
        }

        protected _equal() {
            assert.fail("this structure not define key operation");
        }

        protected _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }

        toObject(): TestReq.Object { 
            return {
                sName: this.sName,
                iAge: this.iAge
            };
        }

        readFromObject(json: TestReq.Object) { 
            _hasOwnProperty.call(json, "sName") && (this.sName = json.sName!);
            _hasOwnProperty.call(json, "iAge") && (this.iAge = json.iAge!);
            return this;
        }

        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }

        static new() {
            return new TestReq();
        }

        static create(is: TarsStream.TarsInputStream) {
            return Hello.TestReq._readFrom(is);
        }
    }

    export namespace TestReq {
        export interface Object {
            sName?: string;
            iAge?: number;
        }
    }

    export class TestRsp {
        iRet: number = 0;
        sMsg: string = "";

        protected _proto_struct_name_ = "";
        protected _classname = "Hello.TestRsp";
        protected static _classname = "Hello.TestRsp";
        protected static _write(os: TarsStream.TarsOutputStream, tag: number, val: any) { os.writeStruct(tag, val); }
        protected static _read(is: TarsStream.TarsInputStream, tag: number, def?: any) { return is.readStruct(tag, true, def); }
        protected static _readFrom(is: TarsStream.TarsInputStream) {
            const tmp = new TestRsp;
            tmp.iRet = is.readInt32(0, false, 0);
            tmp.sMsg = is.readString(1, false, "");
            return tmp;
        }

        protected _writeTo(os: TarsStream.TarsOutputStream) {
            os.writeInt32(0, this.iRet);
            os.writeString(1, this.sMsg);
        }

        protected _equal() {
            assert.fail("this structure not define key operation");
        }

        protected _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }

        toObject(): TestRsp.Object { 
            return {
                iRet: this.iRet,
                sMsg: this.sMsg
            };
        }

        readFromObject(json: TestRsp.Object) { 
            _hasOwnProperty.call(json, "iRet") && (this.iRet = json.iRet!);
            _hasOwnProperty.call(json, "sMsg") && (this.sMsg = json.sMsg!);
            return this;
        }

        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }

        static new() {
            return new TestRsp();
        }

        static create(is: TarsStream.TarsInputStream) {
            return Hello.TestRsp._readFrom(is);
        }
    }

    export namespace TestRsp {
        export interface Object {
            iRet?: number;
            sMsg?: string;
        }
    }

    export class DemoProxy {
        protected _name!: string
        protected _worker!: TarsRpc.ObjectProxy

        setTimeout (iTimeout: number) { this._worker.timeout = iTimeout; }
        getTimeout () { return this._worker.timeout; }
        setVersion (iVersion: number) { this._worker.version = iVersion; }
        getVersion () { return this._worker.version; }

        static testFn = _castFunctionInfo({
            name: "testFn",
            return: "int32",
            arguments: [{
                name: "iLen",
                class: "int32",
                direction: "in"
            }, {
                name: "sName",
                class: "string",
                direction: "in"
            }, {
                name: "stReq",
                class: "Hello.TestReq",
                direction: "in"
            }, {
                name: "iWidth",
                class: "int32",
                direction: "out"
            }, {
                name: "sFullName",
                class: "string",
                direction: "out"
            }, {
                name: "stRsp",
                class: "Hello.TestRsp",
                direction: "out"
            }],
            tarsEncoder(iLen: number, sName: string, stReq: Hello.TestReq) {
                const os = new TarsStream.TarsOutputStream();
                os.writeInt32(1, iLen);
                os.writeString(2, sName);
                os.writeStruct(3, stReq);
                return os.getBinBuffer();
            },
            tarsDecoder(data: TarsRpc.RpcResponse) {
                try {
                    var is = new TarsStream.TarsInputStream(data.response.sBuffer);
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: is.readInt32(0, true, 0),
                            arguments: {
                                iWidth: is.readInt32(4, true, 0),
                                sFullName: is.readString(5, true, ""),
                                stRsp: is.readStruct(6, true, Hello.TestRsp)
                            }
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            tupEncoder(iLen: number, sName: string, stReq: Hello.TestReq, __$PROTOCOL$VERSION: number) {
                const tup = new TarsStream.UniAttribute();
                tup.tupVersion = __$PROTOCOL$VERSION;
                tup.writeInt32("iLen", iLen);
                tup.writeString("sName", sName);
                tup.writeStruct("stReq", stReq);
                return tup;
            },
            tupDecoder(data: TarsRpc.RpcResponse) {
                try {
                    const tup: TarsStream.UniAttribute = (data.response as any).tup;
                    return {
                        request: data.request,
                        response: {
                            costtime: data.request.costtime,
                            return: tup.readInt32("", 0),
                            arguments: {
                                iWidth: tup.readInt32("iWidth"),
                                sFullName: tup.readString("sFullName"),
                                stRsp: tup.readStruct("stRsp", Hello.TestRsp)
                            }
                        }
                    };
                } catch (e) {
                    throw _makeError(data, e.message, TarsRpc.error.CLIENT.DECODE_ERROR);
                }
            },
            errorResponser(data: TarsRpc.RpcResponse) {
                throw _makeError(data, "Call Demo::testFn failed");
            }
        })

        testFn(iLen: number, sName: string, stReq: Hello.TestReq, options?: TarsRpc.InvokeProperty) {
            const version = this._worker.version;
            if (version === TarsStream.Tup.TUP_SIMPLE || version === TarsStream.Tup.TUP_COMPLEX) {
                return this._worker.tup_invoke("testFn", DemoProxy.testFn.tupEncoder(iLen, sName, stReq, version), options, DemoProxy.testFn).then(DemoProxy.testFn.tupDecoder, DemoProxy.testFn.errorResponser);
            } else {
                return this._worker.tars_invoke("testFn", DemoProxy.testFn.tarsEncoder(iLen, sName, stReq), options, DemoProxy.testFn).then(DemoProxy.testFn.tarsDecoder, DemoProxy.testFn.errorResponser);
            }
        }


    }

}


